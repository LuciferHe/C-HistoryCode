/*
题目名称：最长回文字串
来源：http://blog.163.com/zhaohai_1988/blog/static/2095100852012716105847112/

方法四 传说中的Manacher算法。时间复杂度O(N)

这个算法有一个很巧妙的地方，它把奇数的回文串和偶数的回文串统一起来考虑了。这一点一直是在做回文串问题中时比较烦
的地方。这个算法还有一个很好的地方就是充分利用了字符匹配的特殊性，避免了大量不必要的重复匹配。

算法大致过程是这样。先在每两个相邻字符中间插入一个分隔符，当然这个分隔符要在原串中没有出现过。一般可以用‘#’分隔。
这样就非常巧妙的将奇数长度回文串与偶数长度回文串统一起来考虑了（见下面的一个例子，回文串长度全为奇数了），然后用
一个辅助数组P记录以每个字符为中心的最长回文串的信息。P［id］记录的是以字符str［id］为中心的最长回文串，当以
str［id］为第一个字符，这个最长回文串向左右各延伸了P［id］-1 个字符。
原串：    waabwswfd
新串:       # w # a # a # b # w # s # w # f # d #
辅助数组P： 1 2 1 2 3 2 1 2 1 2 1 4 1 2 1 2 1 2 1
这里有一个很好的性质，P［id］-1就是该回文子串在原串中的长度（包括‘#’）。如果这里不是特别清楚，可以自己拿出纸来
画一画，自己体会体会。当然这里可能每个人写法不尽相同，不过我想大致思路应该是一样的吧。

现在的关键问题就在于怎么在O（n）时间复杂度内求出P数组了。只要把这个P数组求出来，最长回文子串就可以直接扫一遍得
出来了。

那么怎么计算P[i]呢？该算法增加两个辅助变量（其实一个就够了，两个更清晰）id和mx，其中id表示当前边界下标最大回文子串中心的
位置，mx则为id+P[id]，也就是该回文子串的边界(不包含在串内)。

然后可以得到一个非常神奇的结论，这个算法的关键点就在这里了：如果mx > i，那么

P[i] >= MIN(P[2 * id - i], mx - i)。就是这个串卡了我非常久。实际上如果把它写得复杂一点，理解起来会简单很多：

// j<i
//记j = 2 * id - i，也就是说 j 是 i 关于 id 的对称点。
if (mx - i > P[j]) P[i] = P[j];
else P[i] = mx - i;    // P[i] >= mx - i，取最小值，之后再匹配更新。

当 mx - i > P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]
为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]。

当 P[j] > mx - i 的时候，以S[j]为中心的回文子串不完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，
也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] >= mx - i。至于mx之后的部分是否
对称，就只能老老实实去匹配了。

由于这个算法是线性从前往后扫的。那么当我们准备求P［i］的时候，i以前的P［j］我们是已经得到了的。我们用mx记在
i之前的回文串中，延伸至最右端的位置。同时用id这个变量记下取得这个最优mx时的id值。（注：为了防止字符比较的时
候越界，我在这个加了‘#’的字符串之前还加了另一个特殊字符‘$’，故我的新串下标是从1开始的）

*/
#include<cstring>
#include<iostream>
using namespace std;

const int N = 300010;
int n, p[N];
char s[N], str[N];

#define _min(x, y) ((x)<(y)?(x):(y))
#define mem(a) memset(a,0,sizeof(a))

void kp(){//计算 p 数组，类似 KMP算法 的next数组
  int i;
  int mx = 0;
  int id;
  for (i = 1; i<n; i++){
    if (mx > i){
      int j = 2 * id - i;//i 关于 id 的对称点， j<i，即p[j]的值已知
      p[i] = _min(p[j], mx - i);
    }
    else p[i] = 1;
    for (; str[i + p[i]] == str[i - p[i]]; p[i]++);
    if (p[i] + i > mx){
      mx = p[i] + i;
      id = i;
    }//if
  }//for
}//kp

void init(){//进行插入间隔字符‘#’操作，这个字符必须是原串中没有的
  int i;
  mem(p);
  mem(str);
  str[0] = '$';//为了保证下标从 1 开始
  str[1] = '#';
  for (i = 0; i<n; i++){
    str[i * 2 + 2] = s[i];
    str[i * 2 + 3] = '#';
  }
  n = n * 2 + 2;
  str[n] = 0;//保险起见 其实没必要 前面已经mem了
}

int main(){
  int i, ans, id=0;
  while (scanf("%s", s) != EOF)
  {
    n = strlen(s);
    init();
    kp();
    ans = 0;
    for (i = 0; i<n; i++){//扫描，选出p[i]值最大的下标，并将p[i]赋给ans，ans-1即为回文字串的最大长度
      if (p[i]>ans){
        ans = p[i];
        id = i;
      }
    }//for

    for (i=id-ans+1;i<=id+ans-1;++i){
      if (str[i] != '#') printf("%c",str[i]);
    }//如果要返回 该字串，又要做一些转换，因为后面的这些操作都是在后来的串上操作的

    printf("\n\nlen: %d\n", ans - 1);
  }
  return 0;
}